# 1. Необходимо написать алгоритм поиска всех доступных комбинаций
# (посчитать количество) для количества кубиков K с количеством граней N.
# 2. У вас есть 2 варианта на выбор – количество кубиков может быть строго
# ограничено (4 кубика, например), либо их количество будет
# динамическим. Выбор за вами.
# 3. Если вы реализуете простой вариант, обращает внимание, что данное
# решение имеет сложность O(n4
# ), но если количество кубиков сделать
# переменной, то она трансформируется в O(nk
# ), что будет представлять
# собой экспоненциальную сложность. Для второго решения очевидно, что
# его сложность O(nk
# ) с самого начала.
import time

n = 6 # количество граней (система счисления)
k = 8 # количество кубиков
start = time.time()
lgr = 0    #int((n ** k - 1) / (n - 1)) к нулей
rgr = n ** k     # к граней с числом n-1 (т.к. нумеруем грани от 0 до n - 1)
li = []
for i in range(lgr, rgr):     # 000...00 (к раз) до (n-1)(n-1)...(n-1) тоже к раз, после перевода в n-ричную систему счисления в строках 23-25
    r = ''
    for j in range(k):
        r += str(i % n)
        i = i // n
    i2 = list(map(int, r))     # разбиваем число в список
    dop = [0] * n              # дополнительный список, в котором содержится
    for f in i2: dop[f] += 1   # количество всех выпавших значений от 0 до n-1 (создаем для сравнения неупорядоченных множеств)
    # print(i2, dop)
    if dop not in li:          # если такого списка еще не было, добавляем в li.
        li.append(dop)
print(len(li))
print(time.time() - start)


li = [{1, 4}, {2, 6}]
print({4, 1} in li)